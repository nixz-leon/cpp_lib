#version 430
#extension GL_ARB_compute_shader : require

// Work group size for matrix multiplication
layout(local_size_x = 16, local_size_y = 16) in;

// Input matrices and output
layout(std430, binding = 0) readonly buffer MatrixA {
    float a[];
};

layout(std430, binding = 1) readonly buffer MatrixB {
    float b[];
};

layout(std430, binding = 2) writeonly buffer Output {
    float result[];
};

// Matrix dimensions
uniform int a_rows;
uniform int a_cols;
uniform int b_cols;

// Tile size for shared memory
#define TILE_SIZE 16

// Shared memory for tiles
shared float tileA[TILE_SIZE][TILE_SIZE];
shared float tileB[TILE_SIZE][TILE_SIZE];

void main() {
    // Global thread IDs
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;
    
    // Local thread IDs
    uint localRow = gl_LocalInvocationID.y;
    uint localCol = gl_LocalInvocationID.x;
    
    // Make sure we don't go out of bounds
    if (row < a_rows && col < b_cols) {
        float sum = 0.0;
        
        // Number of tiles
        int numTiles = (a_cols + TILE_SIZE - 1) / TILE_SIZE;
        
        // Process each tile
        for (int t = 0; t < numTiles; t++) {
            // Load tile from matrix A
            int aRow = row;
            int aCol = t * TILE_SIZE + localCol;
            if (aRow < a_rows && aCol < a_cols) {
                tileA[localRow][localCol] = a[aRow * a_cols + aCol];
            } else {
                tileA[localRow][localCol] = 0.0;
            }
            
            // Load tile from matrix B
            int bRow = t * TILE_SIZE + localRow;
            int bCol = col;
            if (bRow < a_cols && bCol < b_cols) {
                tileB[localRow][localCol] = b[bRow * b_cols + bCol];
            } else {
                tileB[localRow][localCol] = 0.0;
            }
            
            // Synchronize threads to ensure tiles are loaded
            barrier();
            
            // Compute partial sum for this tile
            for (int k = 0; k < TILE_SIZE; k++) {
                sum += tileA[localRow][k] * tileB[k][localCol];
            }
            
            // Synchronize threads before loading next tile
            barrier();
        }
        
        // Store the result
        result[row * b_cols + col] = sum;
    }
}